#+TITLE: Emacs literate configuration 
#+AUTHOR: Mathieu Basille
#+EMAIL: basille@ufl.edu
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes


* Table of Contents                                            :TOC:
 - [[#emacs-packages][Emacs packages]]
   - [[#additional-functions][Additional functions]]
 - [[#interface][Interface]]
   - [[#color-theme][Color theme]]
   - [[#frames][Frames]]
   - [[#windows][Windows]]
   - [[#buffers][Buffers]]
   - [[#mode-line][Mode line]]
   - [[#minibuffer][Minibuffer]]
 - [[#buffer-editing][Buffer editing]]
   - [[#spell-check-and-syntax-check][Spell check and syntax check]]
   - [[#file-saving][File saving]]
 - [[#utilities][Utilities]]
   - [[#file-manager][File manager]]
   - [[#git][GIT]]
   - [[#shell][Shell]]
   - [[#pdf][PDF]]
 - [[#major-modes][Major modes]]
   - [[#yaml][YAML]]
   - [[#org][Org]]
   - [[#latex][LaTeX]]
   - [[#markdown][Markdown]]
   - [[#ess][ESS]]
   - [[#sql][SQL]]
   - [[#web][Web]]
   - [[#polymode][Polymode]]
 - [[#postface][Postface]]

* Emacs packages

Emacs now provide an entire ecosystem of packages, in various
repositories, and handles them through the =package= utility.  Emacs
packages can come from different repositories. We only activate the
official GNU repository, as well as [[http://melpa-stable.milkbox.net/][MELPA-stable]]:

#+BEGIN_SRC emacs-lisp
  (setq package-archives 
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa-stable" . "https://stable.melpa.org/packages/")
          ("melpa" . "https://melpa.org/packages/")
          ("org" . "http://orgmode.org/elpa/")
          )
        package-archive-priorities
        '(("org"          . 20)
          ("melpa-stable" . 10)
          ("gnu"          . 5)
          ("melpa"        . 0)
          ))
#+END_SRC

We now load it and make sure Emacs does not load it automatically 
a second time at startup, after all configuration is loaded:

#+BEGIN_SRC emacs-lisp
  (package-initialize)
  (setq package-enable-at-startup nil)
#+END_SRC

We can now automatically install the packages that are not in Debian
repositories. We first list these packages:

#+BEGIN_SRC emacs-lisp
  (setq package-list '(
                       aggressive-indent
                       anzu
                       auctex
                       auctex-latexmk
                       bonjourmadame
                       col-highlight
                       company
                       company-auctex
                       color-theme-sanityinc-tomorrow 
                       dim
                       dired+
                       dired-narrow
                       dired-quick-sort
                       dired-subtree
                       eshell-git-prompt
                       ess
                       ess-smart-underscore
                       expand-region
                       flx-ido
                       format-sql
                       hideshow-org
                       highlight 
                       highlight-indent-guides
                       ido-completing-read+
                       ido-ubiquitous
                       ido-vertical-mode
                       magit
                       magit-gitflow
                       markdown-mode
                       markdown-toc
                       multiple-cursors
                       neotree
                       pdf-tools
                       polymode
                       org
                       org-bullets
                       powerline
                       smex
                       sql-indent
                       sqlup-mode
                       toc-org
                       web-mode
                       xkcd
                       yaml-mode
                       ))
#+END_SRC

Then fetch the list of packages available and install the missing
packages:

#+BEGIN_SRC emacs-lisp
  (unless package-archive-contents
    (package-refresh-contents))
  (dolist (package package-list)
    (unless (package-installed-p package)
      (package-install package)))
#+END_SRC

From now on, given that all packages are installed with a purpose,
Emacs will silently accept redefinitions of functions by packages (for
instance, =ido-ubiquitous= redefine =ido-completing-read= from =ido=):

#+BEGIN_SRC emacs-lisp
  (setq ad-redefinition-action 'accept)
#+END_SRC

** Additional functions

Additional Lisp functions (=.el= files) are placed in the =functions=
folder of the Emacs profile:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (concat user-emacs-directory "functions"))
#+END_SRC


* Interface

Disable the splash screen:

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
#+END_SRC


** Color theme

Use the theme [[https://github.com/purcell/color-theme-sanityinc-tomorrow][Tomorrow-eighties]] for Emacs GUI, and [[https://github.com/bbatsov/zenburn-emacs][Zenburn]] for Emacs
in the terminal:

#+BEGIN_SRC emacs-lisp
  (if (display-graphic-p) 
      (load-theme 'sanityinc-tomorrow-eighties t)
    (load-theme 'zenburn t))
#+END_SRC


** Frames

Frames (generally called windows) have a title instead of
=emacs25@<computer>=:

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '(buffer-file-name "Emacs: %b (%f)" "Emacs: %b"))
#+END_SRC


** Windows

Emacs starts split horizontaly in the middle:

#+BEGIN_SRC emacs-lisp
  (split-window-horizontally)
#+END_SRC

Open a file in the other window with ~C-x C-o~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-o") 'ido-find-file-other-window)
#+END_SRC

List of buffers with =ibuffer= bound to ~C-x C-b~ (replaces
=list-buffers=):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

Use ~M-<arrows>~ to move between windows (package =windmove=, built in
Emacs):

#+BEGIN_SRC emacs-lisp
  (windmove-default-keybindings 'meta)
#+END_SRC

Next window with ~C-~~ (key above TAB):

#+BEGIN_SRC emacs-lisp
  (global-set-key [C-dead-grave] 'other-window)
#+END_SRC

Mouse wheel does not accelerate:

#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-progressive-speed nil)
#+END_SRC

Scroll 2 lines from the edge:

#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 2)
#+END_SRC

Prevent lateral scrolling from touchpad to beep:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<mouse-7>")
                  (lambda () (interactive)))
  (global-set-key (kbd "<mouse-6>")
                  (lambda () (interactive)))
#+END_SRC

Visible bells (flashes the frame):

#+BEGIN_SRC emacs-lisp
  visible-bell t
#+END_SRC


** Buffers

Empty scratch buffer:

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message nil)
#+END_SRC

Lines soft wrapped at word boundary (with fringe indicators):

#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode 1)
  (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
#+END_SRC

~F10~ to toggle line wrapping (activated by default):

#+BEGIN_SRC emacs-lisp
  (global-set-key [(f10)] 'toggle-truncate-lines)
#+END_SRC

Highlight current line globally (and toggle it with ~C-F10~):

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
  (global-set-key [(ctrl f10)] 'global-hl-line-mode)
#+END_SRC


Highlight columns ([[https://www.emacswiki.org/emacs/col-highlight.el][col-highlight]]): ~C-S-F10~ to toggle column highlight
mode.

#+BEGIN_SRC emacs-lisp
  (global-set-key [(ctrl shift f10)] 'column-highlight-mode)
#+END_SRC

Highlight regions ([[https://www.emacswiki.org/emacs/highlight.el][highlight]]): ~F9~ to highlight, ~C-F9~ to move to
the next highlighted text, ~C-S-F9~ to unhighlight everything.

#+BEGIN_SRC emacs-lisp
  ;; (set-face-attribute 'highlight nil 
  ;;                   :background "saddle brown")
  (global-set-key [(f9)] 'hlt-highlight)
  (global-set-key [(ctrl f9)] 'hlt-next-highlight)
  (global-set-key [(ctrl shift f9)] 'hlt-unhighlight-region)
#+END_SRC

Highlight indentation in Programming mode (=highlight-indent-guides=):

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
  (setq highlight-indent-guides-method 'character) ; use 'column for more visible guides
#+END_SRC

Count words in region using ~C-+~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-+") 'count-words)
#+END_SRC

Kill THIS buffer with ~C-x k~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC


*** Navigation

Backward search with ~C-S-s~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-s") 'isearch-backward)
  (define-key isearch-mode-map (kbd "C-S-s") 'isearch-repeat-backward)
#+END_SRC

[[https://github.com/magnars/expand-region.el][Expand region]] with ~C-=~ (then continue to expand by pressing ~=~ or
contract by pressing ~-~):

#+BEGIN_SRC emacs-lisp
  ;;  (require 'expand-region)
#+END_SRC

[[https://github.com/shanecelis/hideshow-org][HideShow]] (fold or unfold functions/regions with ~TAB~ or ~C-S-F10~ if
the code is already indented) for Programming mode:

#+BEGIN_SRC emacs-lisp
  (require 'hideshow-org)
  (add-hook 'prog-mode-hook
            (lambda()
              (hs-org/minor-mode)
              (local-set-key [(ctrl shift f10)] 'hs-toggle-hiding)
              ))
  (dim-minor-name 'hs-minor-mode "")
#+END_SRC

Saveplace: Go back to last position where the point was in a file
(save positions in =.emacs.d/cache/saved-places=):

#+BEGIN_SRC emacs-lisp
  (save-place-mode 1)
  (setq save-place-file (concat user-emacs-directory "cache/saved-places"))
#+END_SRC

Use position registers (a sort of bookmark) with ~F1—F4~: ~C-F1~ to
~C-F4~ to save a register, ~F1~ to ~F4~ to jump to a saved register:

#+BEGIN_SRC emacs-lisp
  (global-set-key [(f1)]
                  (lambda () (interactive) (jump-to-register 1 nil)))
  (global-set-key [(ctrl f1)]
                  (lambda () (interactive) (point-to-register 1 nil)))
  (global-set-key [(f2)]
                  (lambda () (interactive) (jump-to-register 2 nil)))
  (global-set-key [(ctrl f2)]
                  (lambda () (interactive) (point-to-register 2 nil)))
  (global-set-key [(f3)]
                  (lambda () (interactive) (jump-to-register 3 nil)))
  (global-set-key [(ctrl f3)]
                  (lambda () (interactive) (point-to-register 3 nil)))
  (global-set-key [(f4)]
                  (lambda () (interactive) (jump-to-register 4 nil)))
  (global-set-key [(ctrl f4)]
                  (lambda () (interactive) (point-to-register 4 nil)))
#+END_SRC

Imenu lists the main parts of a document (sections, headers, etc.) to
navigate interactively a long document (bound to ~C-M-=~):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-M-=") #'imenu)
#+END_SRC

Bookmarks are saved in =.emacs.d/cache/bookmarks=, are set with
~C-S-F1~ and listed with ~C-S-F4~:

#+BEGIN_SRC emacs-lisp
  (setq bookmark-default-file (concat user-emacs-directory "cache/bookmarks"))
  (global-set-key [(ctrl shift f1)] 'bookmark-set)
  (global-set-key [(ctrl shift f4)] 'list-bookmarks)
#+END_SRC


** Mode line

Use a Power line:

#+BEGIN_SRC emacs-lisp
  (powerline-center-theme)
  (setq powerline-default-separator 'wave)
#+END_SRC

Display line and column number in the mode line:

#+BEGIN_SRC emacs-lisp
  (column-number-mode 1)
#+END_SRC

[[https://github.com/syohex/emacs-anzu][Anzu]]: display current match and total matches information in the
mode-line, and show replacement interactively. Replace is bound to
~C-r~, and replace using a RegExp is bound to ~C-M-r~:

#+BEGIN_SRC emacs-lisp
  (global-anzu-mode 1)
  (anzu-mode 1)
  (dim-minor-name 'anzu-mode "")
  (global-set-key (kbd "C-r") 'anzu-query-replace)
  (global-set-key (kbd "C-M-r") 'anzu-query-replace-regexp)
#+END_SRC


"Diminish" =auto-fill= (automatically break long lines while typing),
=auto-revert= (which is used by Magit to automatically update file
content), =visual-line-mode= (word wrapping at the end of long lines),
=eldoc= (display function arguments in the minibuffer), Lisp
Interaction (replaced with just "Lisp"):

#+BEGIN_SRC emacs-lisp
  (dim-minor-name 'auto-fill-function "")
  (dim-minor-name 'auto-revert-mode "")
  (dim-minor-name 'visual-line-mode "")
  (dim-minor-name 'eldoc-mode "")
  (dim-minor-name 'eldoc-mode "")
  (add-hook 'emacs-lisp-mode-hook 
            (lambda()
              (setq mode-name "Lisp")))
#+END_SRC


** Minibuffer

Answer with y/n instead of yes/no:

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Enhanced ~M-x~: SMEX, with states saved in the =cache= subfolder (note
that the "old" =M-x= is the command =execute-extended-command=):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
  (setq smex-save-file (concat user-emacs-directory "cache/smex-items"))
#+END_SRC


*** IDO: Interactively Do Things

[[https://www.gnu.org/software/emacs/manual/ido.html][IDO]] allows to Interactively Do Things, more precisely to give
interactively lists of possibilities when opening a file, executing a
function, etc. (note that it is possible to fall back to a normal
prompt using ~C-f~).

Initialize it, and make it work everywhere:

#+BEGIN_SRC emacs-lisp
  (ido-mode 1)
  (ido-everywhere 1)
#+END_SRC

Set up IDO with almost anything that uses completion:

#+BEGIN_SRC emacs-lisp
  (ido-ubiquitous-mode 1)
#+END_SRC

Use IDO in vertical mode:

#+BEGIN_SRC emacs-lisp
  (ido-vertical-mode 1)
#+END_SRC

Use "flex" matching (i.e. typing a few characters will select items
containing these characters in the given order, but not necessarily in
a sequence) with =flx-ido=:

#+BEGIN_SRC emacs-lisp
  (flx-ido-mode 1)
#+END_SRC

Other settings: IDO uses flexible matching, find file at point
intelligently, always create new buffers with ~C-x b~, and saves its
state in the =cache= folder:

#+BEGIN_SRC emacs-lisp
  (setq
   ido-use-filename-at-point 'guess
   ido-create-new-buffer 'always
   ;; ido-file-extensions-order '(".Rmd" ".R" ".tex" ".el") ; extension order
   ido-save-directory-list-file (concat user-emacs-directory "cache/ido"))
#+END_SRC

Cycle through buffers with =IDO= (~C-TAB~ in this window and ~C-S-TAB~
in the other window):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<C-tab>") 'ido-switch-buffer)
  (global-set-key (kbd "<C-iso-lefttab>") 'ido-switch-buffer-other-window) ; C-S-TAB
#+END_SRC

Type ~$~ in IDO find file to [[https://scottfrazersblog.blogspot.com/2009/12/emacs-using-bookmarked-directories.html][go to a bookmark]]:

#+BEGIN_SRC emacs-lisp
  (require 'bookmark)
  
  (defun my-ido-bookmark-jump ()
    "Jump to bookmark using ido"
    (interactive)
    (let ((dir (my-ido-get-bookmark-dir)))
      (when dir
        (find-alternate-file dir))))
  
  (defun my-ido-get-bookmark-dir ()
    "Get the directory of a bookmark."
    (let* ((name (ido-completing-read "Find bookmark: " (bookmark-all-names) nil t))
           (bmk (bookmark-get-bookmark name)))
      (when bmk
        (setq bookmark-alist (delete bmk bookmark-alist))
        (push bmk bookmark-alist)
        (let ((filename (bookmark-get-filename bmk)))
          (if (file-directory-p filename)
              filename
            (file-name-directory filename))))))

  (defun my-ido-use-bookmark-dir ()
    "Get directory of bookmark"
    (interactive)
    (let* ((enable-recursive-minibuffers t)
           (dir (my-ido-get-bookmark-dir)))
      (when dir
        (ido-set-current-directory dir)
        (setq ido-exit 'refresh)
        (exit-minibuffer))))

  (define-key ido-file-dir-completion-map (kbd "$") 'my-ido-use-bookmark-dir)
#+END_SRC


* Buffer editing

Never use Tabs when indenting, use spaces instead:

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

Delete selection mode (replace a selection):

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

Undo with ~C-z~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-z") 'undo)
#+END_SRC

Electric pair mode: Automatically close double quotes, back quotes,
parentheses, square brackets and curly brackets:

#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)
  (setq electric-pair-pairs '(
                              (?\" . ?\")
                              (?\` . ?\`)
                              (?\( . ?\))
                              (?\[ . ?\])
                              (?\{ . ?\})
                              ) )
#+END_SRC

Show matching parentheses and other characters (without any delay):

#+BEGIN_SRC emacs-lisp
  (setq show-paren-delay 0)
  (show-paren-mode 1)
#+END_SRC

[[https://github.com/Malabarba/aggressive-indent-mode][Aggressive indent]] in Programming mode to indent automatically all
blocks when a part is moved (add modes to
=aggressive-indent-excluded-modes= to NOT start aggressive indent in
this mode) [NOTE: Disabled because of bugs with Polymode!]:

#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'prog-mode-hook #'aggressive-indent-mode)
#+END_SRC

Automatically break long lines (by default after 70 characters, as set
in the variable =fill-column=): 

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC

Consider CamelCase as two words in programming modes (but don't show
it with "," in the mode line):

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'subword-mode)
  (dim-minor-name 'subword-mode "" 'subword)
#+END_SRC

Complete anything (=company=), with ~TAB~ (=(kbd "TAB")= for terminal;
=[tab]= for graphical mode) to complete immediately, no delay and
aggressive completion:

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'global-company-mode)
  (dim-minor-name 'company-mode "" 'company)
  (with-eval-after-load 'company
    (define-key company-active-map (kbd "TAB") #'company-complete-common)
    (define-key company-active-map [tab] #'company-complete-common))
  (setq company-idle-delay 0
        company-echo-delay 0
        company-dabbrev-downcase nil
        company-minimum-prefix-length 2
        company-selection-wrap-around t
        company-transformers '(company-sort-by-occurrence
                               company-sort-by-backend-importance))
#+END_SRC

Multiple cursors (=multiple-cursors=), choices are saved in the
=cache= folder; ~F11~ to have multiple cursors in all lines of a
region; ~C-F11~ tries to be smart about marking everything you want
(can be pressed multiple times); ~C-S-F11~ marks the next item like
the selection (use then arrows to select more/less):

#+BEGIN_SRC emacs-lisp
  (setq mc/list-file (concat user-emacs-directory "cache/mc-lists.el"))
  (global-set-key [(f11)] 'mc/edit-lines)
  (global-set-key [(ctrl f11)] 'mc/mark-all-dwim)
  (global-set-key [(ctrl shift f11)] 'mc/mark-more-like-this-extended)
  (global-set-key (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click)
#+END_SRC

Magnar Sveen wrote a [[https://github.com/magnars/.emacs.d/blob/master/defuns/lisp-defuns.el][very useful function]] to evaluate and directly
replace a Lisp expression. For instance, evaluating =(+ 1 2)= replaces
the expression by =3= (works in any buffer). It is bound to ~C-x C-y~:

#+BEGIN_SRC emacs-lisp
  (load-library "sexp-eval-and-replace")
  (global-set-key (kbd "C-x C-y") 'sexp-eval-and-replace)
#+END_SRC


** Spell check and syntax check

Emacs built-in spell check package is Ispell. A good approach is to
use =Hunspell= as the spell check engine (needs to be installed), with
"en_US" as the default dictionary (~C-S-F12~ to change
dictionary). =Flyspell= (spell check on the fly) is enabled by default
in all text files (~C-F12~ to toggle Flyspell), and in programming
mode (only in the comments) in programming files. ~F12~ (or middle
click) opens the list of correction suggestions:

#+BEGIN_SRC emacs-lisp
  (setq ispell-program-name "hunspell"
        ispell-local-dictionary "en_US")

  (add-hook 'text-mode-hook 'turn-on-flyspell)
  (add-hook 'prog-mode-hook 'flyspell-prog-mode)

  (global-set-key [f12] 'flyspell-correct-word-before-point)
  (global-set-key [C-f12] 'flyspell-mode) ; + flyspell-buffer when on!
  (global-set-key [C-S-f12] 'ispell-change-dictionary)
#+END_SRC


** File saving

Default language environment is UTF-8:

#+BEGIN_SRC emacs-lisp
  (setq current-language-environment "UTF-8")
#+END_SRC

Don't lock files and accepts simultaneous editing (no [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Interlocking.html][interlocking]],
which creates tmp lockfiles):

#+BEGIN_SRC emacs-lisp
  (setq create-lockfiles nil)
#+END_SRC

[[http://www.emacswiki.org/emacs/AutoSave][Auto-save]] in =~/.emacs.d/save= (after 10 seconds or 100 characters):

#+BEGIN_SRC emacs-lisp
  (setq
   auto-save-file-name-transforms `((".*" ,"~/.emacs.d/save/\\1" t))
   auto-save-list-file-name (concat user-emacs-directory "cache/save-list")
   auto-save-interval 100
   auto-save-timeout 10)
#+END_SRC

[[http://www.emacswiki.org/emacs/BackupDirectory][Backups]] in =~/.emacs.d/save= (a backup happens everytime a file is
open, and then on each subsequent saves). Copy backup files, keep a
versioned (numbered) backup, and only keep the first 2 and last 2
versions of each backup:

#+BEGIN_SRC emacs-lisp
  (defvar save-dir (concat user-emacs-directory "cache/save"))
  (setq
   backup-directory-alist (list (cons "." save-dir))
   backup-by-copying t
   version-control t
   kept-new-versions 2
   kept-old-versions 2
   delete-old-versions t)
                                          #+END_SRC

Abbreviations ([[https://www.gnu.org/software/emacs/manual/html_node/emacs/Abbrevs.html][Abbrevs]]) are a way to save keystrokes by expanding
words into longer text. Since I don't use it, it gets slightly in the
way. I tell Emacs to save abbreviations in the cache directory
silently:

#+BEGIN_SRC emacs-lisp
  (setq abbrev-file-name (concat user-emacs-directory "cache/abbrev_defs"))
  (setq save-abbrevs 'silently)
#+END_SRC


* Utilities


** File manager

=Dired= (launched in current directory with with ~C-F5~) list
directories first, refresh automatically directories, intelligently
guess where to copy (other window), and does not ask for confirmation
for recursive copies and deletes. Switch to WDired mode (to 'write'
file names) with ~C-S-F5~, go to bookmarks with ~$~, insert/remove
subdirectories with ~i~ and ~<backspace>~ (with [[https://github.com/Fuco1/dired-hacks#dired-subtree][Dired-subtree]]),
dynamically filter files and folders with ~/~ (part of [[https://github.com/Fuco1/dired-hacks#dired-narrow][Dired-narrow]]),
and =ediff= two marked files with ~e~ (with =dired-ediff-files=):

#+BEGIN_SRC emacs-lisp
  (setq
   dired-listing-switches "-aBhl  --group-directories-first"
   ;; dired-omit-files "^\\.$"
   dired-auto-revert-buffer t
   dired-dwim-target t
   dired-recursive-copies (quote always)
   dired-recursive-deletes (quote always))
  (global-set-key (kbd "C-<f5>")
                  (lambda ()
                    (interactive)
                    (dired ".")))
  (add-hook 'dired-mode-hook 'auto-revert-mode)
  (eval-after-load "dired"
    '(progn
       (load-library "dired-ediff-files")
       (hl-line-mode)
       (define-key dired-mode-map [(ctrl shift f5)] #'dired-toggle-read-only)
       (define-key dired-mode-map "$" 'my-ido-bookmark-jump)
       (define-key dired-mode-map "i" 'dired-subtree-insert)
       (define-key dired-mode-map (kbd "<backspace>") 'dired-subtree-remove)
       (define-key dired-mode-map "/" 'dired-narrow)
       (define-key dired-mode-map "e" 'dired-ediff-files)
       ))
#+END_SRC

In addition, [[https://www.emacswiki.org/emacs/DiredPlus][Dired+]] allows to use a single buffer for visited folders
with Dired (as well as providing richer highlighting including
mouse-over highlighting, and wrap around navigation), and we want the
Dired buffer to start with details displayed. [[https://gitlab.com/xuhdev/dired-quick-sort][dired-quick-sort]] allows
to interactively sort Dired buffers:

#+BEGIN_SRC emacs-lisp
  (setq diredp-hide-details-initially-flag nil)
  (diredp-toggle-find-file-reuse-dir 1)
  (dired-quick-sort-setup)
#+END_SRC

Remove =.= from the list of files/folders (and be silent about it):

#+BEGIN_SRC emacs-lisp
  (setq-default dired-omit-files-p t)
  (setq
   dired-omit-verbose nil
   dired-omit-files "^\\.$"
   dired-omit-extensions nil)
#+END_SRC

Use [[https://github.com/jaypei/emacs-neotree][NeoTree]] to have a tree explorer on the side (bound to
~F5~):

#+BEGIN_SRC emacs-lisp
  (setq neo-theme 'ascii)
  (global-set-key [(f5)] 'neotree-toggle)
#+END_SRC

TRAMP history of connections in =.emacs.d/cache/tramp=, make
completion faster, shell history in standard location
("$HOME/.sh_history"), backups of remote files disabled, and just to
be sure, version control is disabled on remote files (although VC is
already disable entirely below:

#+BEGIN_SRC emacs-lisp
  (setq
   tramp-persistency-file-name (concat user-emacs-directory "cache/tramp")
   tramp-completion-reread-directory-timeout nil
   tramp-histfile-override nil
   )
  (add-to-list 'backup-directory-alist
               (cons tramp-file-name-regexp nil))
  (setq vc-ignore-dir-regexp
        (format "\\(%s\\)\\|\\(%s\\)"
                vc-ignore-dir-regexp
                tramp-file-name-regexp))
#+END_SRC


** GIT

[[https://magit.vc/][Magit]] is a interface to Git completely integrated to Emacs. Once
installed, it pretty much works out of the box, there are just a
couple of settings to make it even smoother (remove Git from the list
of backends handled by Emacs version control; use IDO to complete;
links to Git-man; automatically refresh the repository's status after
file save). We also bound Magit to ~F6~, and integrate Git-flow to
Magit (=magit-gitflow=, started with ~C-f~ from within Magit):

#+BEGIN_SRC emacs-lisp
  (global-set-key [(f6)] 'magit-status)
  ;; (setq vc-handled-backends (delq 'Git vc-handled-backends))
  (setq vc-handled-backends nil)
  (setq
   magit-completing-read-function 'magit-ido-completing-read
   magit-view-git-manual-method 'man
   )
  (with-eval-after-load 'magit
    (add-hook 'after-save-hook 'magit-after-save-refresh-status))
  (add-hook 'magit-mode-hook 'turn-on-magit-gitflow)
#+END_SRC

** Shell

Emacs provide different possibilities to embed a Shell (for instance,
~M-x shell~, ~M-x ansi-term~), with different advantages and
drawbacks. Here I setup Eshell (the Emacs shell, ~M-x eshell~), with
short names to [[https://www.emacswiki.org/emacs/EshellRedirection][redirect to buffers]] and completion that ignores
case. [[https://github.com/xuchunyang/eshell-git-prompt][eshell-git-prompt]] enables detection of Git repositories and
brings a nice powerline:

#+BEGIN_SRC emacs-lisp
  (setq
   eshell-buffer-shorthand t
   eshell-cmpl-ignore-case t)
  (eshell-git-prompt-use-theme 'powerline)
#+END_SRC

In Shell, use ~C-l~ to send commands directly to the subshell (useful
for =screen= for instance):

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'shell
    (define-key shell-mode-map (kbd "C-l") (lambda (seq) (interactive "k") (process-send-string nil seq))))
#+END_SRC

Finally, a function =shell-xterm= (~C-F6~) launches a shell with
clearing capabilities (needed for =screen=):

#+BEGIN_SRC emacs-lisp
  (load-library "shell-xterm.el")
  (global-set-key [(ctrl f6)] 'shell-xterm)
#+END_SRC


** PDF

Use PDF tools to view PDF (=libpoppler-glib-dev= required):

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.pdf" . pdf-tools-install))
#+END_SRC

From within a PDF, use ~P~ to fit the zoom to the page; ~H~ to
the height, ~W~ to the width; ~g~ refreshes (reverts) the PDF; ~h~
opens the help of PDF tools.



* Major modes


** YAML

=YAML-mode= for YAML headers/files:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
#+END_SRC


** Org

Org mode comes with its own keybindings, ([[http://orgmode.org/manual/Conflicts.html][which can easily conflict
with other settings]]).

#+BEGIN_SRC emacs-lisp
  (setq org-replace-disputed-keys t)
  #+END_SRC

Make nice UTF-8 bullet points:

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC

# [not working]
#
# To make windmove active in locations where Org mode does not have
# special functionality on M-<cursor>:
#
# #+BEGIN_SRC emacs-lisp
# (add-hook 'org-metaup-final-hook 'windmove-up)
# (add-hook 'org-metaleft-final-hook 'windmove-left)
# (add-hook 'org-metadown-final-hook 'windmove-down)
# (add-hook 'org-metaright-final-hook 'windmove-right)
# #+END_SRC


Table of contents with [[https://github.com/snosov1/toc-org][Toc-Org]] (just add a =:TOC:= tag with 
~C-c C-q~ in the first header, and the table of contents will be
automatically updated on file save):

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'toc-org-enable) 
#+END_SRC


Org-babel can recognize code blocks [[http://orgmode.org/manual/Languages.html][from many different languages]] (Lisp,
Bash, R, etc.) and provides a way to edit them in their respective
mode (~C-c '~; and same keybinding to close). However,  =polymode=
provides an even better integration directly in the Org file. We load
a few languages:

#+BEGIN_SRC emacs-lisp 
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((css . t)
       (ditaa . t)
       (emacs-lisp . t)
       (latex . t)
       (lilypond . t)
       (org . t)
       (sh . t)
       (sql . t)
       (R . t))))
  #+END_SRC

Give the correct path to the Ditaa java library:

#+BEGIN_SRC emacs-lisp
  (setq org-ditaa-jar-path (expand-file-name "/usr/share/ditaa/ditaa.jar"))
#+END_SRC


# ;; Keeping notes and TODO lists: org-mode
# (use-package org
# 	     ;; See config at: http://writequit.org/org/settings.html#sec-1-6x
# 	     :mode (("\\.org$" . org-mode))	; Activate Org for .org files
# 	     :bind (("C-c l" . org-store-link)
# 		    ("C-c a" . org-agenda)
# 		    ("C-c b" . org-iswitchb)
# 		    ("C-c c" . org-capture)
# 		    ("C-c M-p" . org-babel-previous-src-block)
# 		    ("C-c M-n" . org-babel-next-src-block)
# 		    ("C-c S" . org-babel-previous-src-block)
# 		    ("C-c s" . org-babel-next-src-block)
# 		    ([(f6)] . org-todo-list) ; Global TODO list
# 		    ([(control f6)] . org-ctrl-c-ctrl-c) ; C-c C-c 
# 		    ([(f7)] . org-insert-todo-here) ; Insert TODO at point
# 		    ([(control f7)] . org-todo)	 ; Rotate TODO state
# 		    ([(control shift f7)] . org-show-todo-tree)	 ; Shows TODOs in current buffer
# 		    ;; (:map org-mode-map		  ; Edit code block in its specific mode
# 		    ;;       ([(control shift f6)] . org-edit-special))
# 		    ;; (:map org-src-mode-map		; Exit code block editing
# 		    ;;       ([(control shift f6)] . org-edit-srv-exit))
# 		    )
# 	     :config
# 	     (progn
# 	       (org-defkey org-mode-map [(ctrl shift f6)] 'org-edit-special) ; Edit code block in its specific mode
# 	       (org-defkey org-src-mode-map [(ctrl shift f6)] 'org-edit-src-exit) ; Exit code block editing
# 	       (setq
# 		;; Display
# 		org-hide-emphasis-markers t	; Hide markers
# 		org-ellipsis "⤵"			; Downward-pointing arrow instead of the usual …
# 		org-src-fontify-natively t		; Use syntax highlighting in source blocks
# 		org-src-tab-acts-natively t	; Make TAB act like the language's major mode in source blocks
# 		;; org-startup-folded 'overview ; Start with top level headlines visible
# 		org-display-inline-images t	; Enable inline images
# 		;; org-directory 			; Where Org checks for files
# 		;; org-archive-location		; Folder for archiving an entry
# 		org-agenda-files '("~/.emacs.d/org") ; List of files for agenda/TODOs
# 		;; org-support-shift-select 'always	; Allows shift selection
# 		org-return-follows-link t		; Follow links by pressing ENTER on them
# 					; (alternative to C-c C-o / M-x org-open-at-point)
# 		org-replace-disputed-keys t	; Conflicting keys
# 					; http://orgmode.org/manual/Conflicts.html
# 		org-default-notes-file (concat org-directory "/notes.org")
# 					;
# 		org-log-done t		   ; Insert dates for changes in TODOs
# 		org-todo-keywords ; TODO keywords: http://orgmode.org/manual/TODO-extensions.html#TODO-extensions
# 					; http://orgmode.org/guide/Tracking-TODO-state-changes.html#Tracking-TODO-state-changes
# 					; @ requires a note
# 					; ! puts a timestamp (not necessary for DONE)
# 		;; '((sequence "SOMEDAY(s)" "NOW(n)" "LATER(l)" "WAITING(w@/!)" "NEEDSREVIEW(n@/!)" "|" "DONE(d)")
# 		'((sequence "SOMEDAY(s)" "NOW(n!)" "LATER(l)" "PROJECT(p)" "CANCELLED(c@/!)" "|" "DONE(d)"))
# 		;; (sequence "REPORT(r)" "BUG(b)" "KNOWNCAUSE(k)" "|" "FIXED(f)"))
# 		org-todo-keyword-faces		; ORG faces
# 		'(("SOMEDAY" :foreground "purple" :weight bold)
# 		  ("NOW" :foreground "orange" :weight bold)
# 		  ("LATER" :foreground "forest green" :weight bold)
# 		  ("PROJECT" :foreground "blue" :weight bold)
# 		  ("CANCELLED" :foreground "red" :weight bold)
# 		  ("DONE" :foreground "gray" :weight bold))
# 		org-use-fast-todo-selection t	; Menu with selection of TODO keywords
# 		org-enforce-todo-dependencies t	; Parent can't be marked as done unless all children are done
# 		)
# 	       (defun org-summary-todo (n-done n-not-done)
# 		 "Switch entry to DONE when all subentries are done, to SOMEDAY otherwise."
# 		 (let (org-log-done org-log-states)   ; turn off logging
# 		   (org-todo (if (= n-not-done 0) "DONE" "SOMEDAY"))))
# 	       ;; Insert TODO at point
# 	       (load-library "org-insert-todo-here")
# 	       ;; DISPLAY
# 	       (font-lock-add-keywords 'org-mode	; Real bullets
# 				       '(("^ +\\([-*+]\\) "
# 					  (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
# 	       ;; Nice headers
# 	       (let* ((variable-tuple (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
# 					    ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
# 					    ((x-list-fonts "Verdana")         '(:font "Verdana"))
# 					    ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
# 					    (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
# 		      (base-font-color     (face-foreground 'default nil 'default))
# 		      (headline           `(:inherit default :weight bold :foreground ,base-font-color)))
# 		 (custom-theme-set-faces 'user
# 					 `(org-level-8 ((t (,@headline ,@variable-tuple))))
# 					 `(org-level-7 ((t (,@headline ,@variable-tuple))))
# 					 `(org-level-6 ((t (,@headline ,@variable-tuple))))
# 					 `(org-level-5 ((t (,@headline ,@variable-tuple))))
# 					 `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
# 					 `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
# 					 `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
# 					 `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
# 					 `(org-document-title ((t (,@headline ,@variable-tuple :height 1.5 :underline nil))))))
# 	       (use-package org-bullets	; Header bullets
# 					; https://github.com/sabof/org-bullets
# 			    :config
# 			    (progn
# 			      (require 'org-bullets)		; 
# 			      (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))))
# 	       ))


** LaTeX

The main package for LaTeX in Emacs is AUCTeX. In this configuration,
AUCTeX integrates RefTeX (references), LatexMk (compilation) and PDF
Tools (visualization). Note that compilation logs are not shown by
default (use ~C-c C-l~ to see them, or add =(setqTeX-show-compilation
t)= in the =LaTeX-mode-hook=). We start by configuring the LaTeX mode
(notably RefTeX, fold LaTeX environments [F], Math mode [M],
compilation as PDF [P], forward and inverse search [S]):

#+BEGIN_SRC emacs-lisp
  (setq TeX-parse-self t                ; Enable parse on load.
        TeX-auto-save t                 ; Enable parse on save.
        TeX-source-correlate-mode t	; Forward and inverse search
        TeX-clean-confirm nil ; Don't ask for confirmation to clean intermediary files
        reftex-plug-into-AUCTeX t       ; Plug RefTeX to AUCTeX
        TeX-auto-untabify t             ; Replace Tabs by spaces on save
        )
  (add-hook 'LaTeX-mode-hook 
            (lambda ()
              (TeX-global-PDF-mode t)   ; Compile as PDF
              (LaTeX-math-mode)         ; Math mode
              (turn-on-reftex)          ; RefTeX on
              (outline-minor-mode 1)	; Fold LaTeX sections
              (TeX-fold-mode 1)         ; Fold LaTeX environments
              ))
  (dim-minor-name 'reftex-mode "" 'reftex)
  (dim-minor-name 'outline-minor-mode "" 'outline)
#+END_SRC

The compilation by LatexMk (a single call to perform all necessary
LaTeX/BibTeX compilations) is performed through the [[https://github.com/tom-tan/auctex-latexmk][auctex-latexmk]]
package, which allows to have LatexMk as the default engine for LaTeX compilation:

#+BEGIN_SRC emacs-lisp
  (setq auctex-latexmk-inherit-TeX-PDF-mode t) ; LaTeXMk inherits PDF mode 
  (with-eval-after-load "tex"
    (auctex-latexmk-setup))
  (add-hook 'TeX-mode-hook (lambda () (setq TeX-command-default "LatexMk")))
#+END_SRC

We also enable completion for LaTeX commands using Company:

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load "tex"
    (company-auctex-init)
    )
#+END_SRC

Finally, we enable the use of PDF tools to visualize the resulting PDF
and refresh it automatically:

#+BEGIN_SRC emacs-lisp
  (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
        TeX-source-correlate-start-server t)
  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
#+END_SRC

# ;; Clean up intermediary files with LaTeXmk and Beamer
# (add-to-list 'LaTeX-clean-intermediate-suffixes "\\.fdb_latexmk" t)
# (add-to-list 'LaTeX-clean-intermediate-suffixes "\\.vrb" t)

# ;; Pour utiliser le langage de babel en mode LaTeX avec flyspell-babel :
# ;; http://www.dur.ac.uk/p.j.heslin/Software/Emacs/
# ;; FAIT PLANTER FLYSPELL ! 
# ;; (autoload 'flyspell-babel-setup "flyspell-babel")
# ;; (add-hook 'LaTeX-mode-hook 'flyspell-babel-setup)
# ;; (setq flyspell-babel-delay 1)  ; Delai avant "reparsing" du block. Ça marche ça ?
# ;; (setq flyspell-babel-verbose t)
# ;; (setq flyspell-babel-to-ispell-alist
# ;;       '(("french" "fr_FR")
# ;; 	("english" "en")
# ;; 	("american" "en_US")
# ;; 	("canadian" "en_CA")
# ;; 	("british" "en_GB")))
# ;; Comment avoir à nouveau le \og quand on est en français et qu'on tape " ?


** Markdown

[[http://jblevins.org/projects/markdown-mode/][Markdown-mode]] is used to edit Markdown files (=.md= or =.markdown=)
and is loaded automatically. We simply enable Math:

# BUG with markdown-toc; see bug report with M-x markdown-toc-bug-report
# 
# , and integrate
# =[[https://github.com/ardumont/markdown-toc][markdown-toc]]= (type ~M-x markdown-toc-generate-toc~ to generate Table
# of contents at point):

#+BEGIN_SRC emacs-lisp
  (setq markdown-enable-math t)
#+END_SRC

# (add-hook 'markdown-mode-hook 
# 		 (lambda ()
# 		   (imenu-add-menubar-index) ; Add imenu


** ESS

ESS to use R, edit R script, edit R documentation (Roxygen) and
prepare packages. ESS is simply loaded with:

R is not a =prog-mode=, so it needs its own settings in the ESS hook.

[[https://github.com/mattfidler/ess-smart-underscore.el][ESS Smart Underscore]]


#+BEGIN_SRC emacs-lisp
  (require 'ess-site)
  (setq
   ess-default-style 'OWN
   inferior-ess-same-window nil         ; Run R in inferior window
   ess-ask-for-ess-directory nil ; Use current directory as working directory
   inferior-R-args "--quiet --no-save"  ; No save on exit
   ess-nuke-trailing-whitespace-p t     ; remove trailing spaces
   comint-scroll-to-bottom-on-input t ; Always scroll to the end of the R buffer
   comint-scroll-to-bottom-on-output t ; Scroll automatically when output reaches bottom
   ;; comint-move-point-for-output t
   ess-eval-visibly 'nowait             ; Does not wait for R
   ess-swv-processor 'knitr ; Use knitr instead of Sweave as ESS processor
   ess-roxy-fontify-examples t ; Syntax highlighting in Roxygen examples
   ess-swv-plug-into-auctex-p t ; Add integration of Sweave/Kniter into AUCTeX
   )
  (custom-set-variables
   '(ess-own-style-list
     (quote
      ((ess-indent-offset . 4)
       (ess-offset-arguments . prev-line)
       (ess-offset-arguments-newline . prev-line)
       (ess-offset-block . prev-line)
       (ess-offset-continued . straight)
       (ess-align-nested-calls)
       (ess-align-arguments-in-calls)
       (ess-align-continuations-in-calls . prev-line)
       (ess-align-blocks control-flow)
       (ess-indent-from-lhs)
       (ess-indent-from-chain-start)
       (ess-indent-with-fancy-comments . t)))))  
#+END_SRC

# (defcustom ess-own-style-list (cdr (assoc 'RRR ess-style-alist))
#   "Indentation using R parser rules"
#   :group 'ess-edit
#   :type 'alist
#   :initialize 'custom-initialize-set
#   :set (lambda (symbol value)
#          (set symbol value)
#          (ess-add-style 'R value)))

#+BEGIN_SRC emacs-lisp
  (add-hook 'ess-mode-hook 
            (lambda ()
              (flyspell-prog-mode)
              (require 'ess-smart-underscore) 
              (highlight-indent-guides-mode) ; Highlight indentation using
                                        ; 'highlight-indent-guides'
              (subword-mode) ; Consider CamelCase as two words             
              (hs-org/minor-mode) 
              (local-set-key [(ctrl shift f10)] 'hs-toggle-hiding)
              ;; (aggressive-indent-mode)
              ;; (myindent-ess-hook)
              (add-hook 'local-write-file-hooks ; Remove trailing white spaces on save
                        (lambda ()
                          (ess-nuke-trailing-whitespace)))
              ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'ess-R-post-run-hook 
            'ess-execute-screen-options) ; Sets R option "width" to the width of the R 
                                        ; buffer on startup
#+END_SRC

Use the R parser (ess-indent-region-as-r) or formatR
(ess-indent-region-with-formatr) to format R code. The later
is bound to C-M-\ ou 'M-x indent-region'.

#+BEGIN_SRC emacs-lisp  
  (add-hook 'ess-mode-hook
            (lambda ()
              (load-library "ess-indent-region-r")
              (set (make-local-variable 'indent-region-function)
                   'ess-indent-region-with-formatr)))
#+END_SRC

In an ESS inferior buffer, use ~C-l~ to send commands directly to the
subshell ([[https://stat.ethz.ch/pipermail/ess-help/2010-July/006202.html][useful for =screen= for instance]]):

#+BEGIN_SRC emacs-lisp
  (define-key inferior-ess-mode-map (kbd "C-l")
    (lambda (seq) (interactive "k")
      (process-send-string nil seq)))
#+END_SRC

In (R)Markdown, add a fenced R code block (~C-return~) or inline R
code (~C-S-return~); weave with ~F7~; export with ~C-F7~; use
=knitr::pandoc= with options in =.pandoc/config.pandoc= with ~F8~, and
render a bookdown with ~C-F8~:

#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook 
            (lambda ()
              (load-library "rmd-library.el")
              (local-set-key [C-return] 'rmd-fenced-r-code-block)
              (local-set-key [C-S-return] 'rmd-inline-r-code)
              ))
  (with-eval-after-load 'polymode
    (define-key polymode-mode-map [(f7)] #'polymode-weave)
    (define-key polymode-mode-map [(ctrl f7)] #'polymode-export)
    (define-key polymode-mode-map [(f8)] #'rmd-pandoc-custom)
    (define-key polymode-mode-map [(ctrl f8)] #'rmd-bookdown))
#+END_SRC

# (defun ess-remote-r ()		; Associate R remote buffer to ESS buffer
    #   (interactive) (ess-remote nil "R"))
# (bind-key "\C-cw" 'ess-execute-screen-options inferior-ess-mode-map) ; C-c w to adjust
# 					; the width of the R buffer
# (bind-keys :map ess-mode-map
             # 	 ("C-c C-x" . ess-eval-chunk)		; C-c C-x to evaluate a R chunk (C-c C-c 
                       # 					; should jump to the next block and C-M-x evaluates
                       # 					; and stays in place)
                       # 	 ([(control shift f8)] . ess-swv-tangle)))) ; C-S-F7 to tangle
# 	 ;; ([(f8)] . ess-display-vignettes)	 ; F8 to display the list of vignettes
# 	 ;; ([(ctrl shift f8)] . ess-remote-r)))) ; C-S-F8 to
# associate R remote buffer to ESS buffer


** SQL

SQL works already well out of the box. I set ~C-return~ to send a
region (if selected) or the current paragraph:

#+BEGIN_SRC emacs-lisp
  (add-hook 'sql-mode-hook
            (lambda ()
              (load-library "sql-library")
              (local-set-key (kbd "<C-return>") 'sql-send-region-or-paragrap)))
#+END_SRC

However, more configuration is required to have a beautiful code and
readable output. First of all, [[https://github.com/bsvingen/sql-indent][sql-indent]] allows to indent correctly
SQL code:

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'sql (load-library "sql-indent"))
#+END_SRC

In addition to it, [[https://github.com/Trevoke/sqlup-mode.el][SQL-up]] automatically corrects lower case SQL
reserved names (=SELECT=, =FROM=, etc.). If necessary, it is called
with ~C-c u~ on a region:

#+BEGIN_SRC emacs-lisp
  (add-hook 'sql-mode-hook 'sqlup-mode)
  (add-hook 'sql-interactive-mode-hook 'sqlup-mode)
  (add-hook 'sql-mode-hook
            (lambda ()
              (local-set-key (kbd "C-c u") 'sqlup-capitalize-keywords-in-region)))
#+END_SRC

To make it a step further, [[https://github.com/emacsmirror/format-sql][format-sql]] integrates the Python library of
the same name, and allows to completely format the code in a region
with ~C-M-]~ (an alternative is [[https://github.com/ldeck/SqlBeautify][SQL-beautify]]):

#+BEGIN_SRC emacs-lisp
  (add-hook 'sql-mode-hook
            (lambda ()
              (local-set-key (kbd "C-M-]") 'format-sql-region)))
#+END_SRC

# ;; (defun format-sql-region-or-buffer ()
# ;;   "Format SQL for the entire buffer or the marked region"
# ;;   (interactive)
# ;;   (if (use-region-p)
# ;;       (format-sql-bf--apply-executable-to-buffer "format-sql"
# ;;                                                  'format-sql--call-executable
# ;;                                                  t
# ;;                                                  (get-file-type)))
# ;;   (format-sql-bf--apply-executable-to-buffer "format-sql"
# ;;                                              'format-sql--call-executable
# ;;                                              nil
# ;;                                              (get-file-type)))

Set up default PostgreSQL credentials:

#+BEGIN_SRC emacs-lisp
  (setq sql-postgres-login-params
        '((server :default "localhost")
          (port :default 5432)
          (user :default "mathieu")
          (database :default "test")))
#+END_SRC
  
# If several servers:

# #+BEGIN_SRC emacs-lisp :tangle no
#   (setq sql-connection-alist
#         '((server1
#            (sql-product 'postgres)
#            (sql-server "localhost")
#            (sql-port 5432)
#            (sql-database "DATABASE")
#            (sql-user "USER"))
#           (eurodeer
#            (sql-product 'postgres)
#            (sql-server "www.server.org")
#            (sql-port 5432)
#            (sql-database "DATABASE")
#            (sql-user "USER")
#            (sql-password "PASSWORD"))))
# #+END_SRC

# #+BEGIN_SRC emacs-lisp
#   (add-hook 'sql-mode-hook
#             (lambda ()
#               (load-library "sql-connection-alist")))
# #+END_SRC

In the output, we first make sure that lines are not truncated (DOES
NOT WORK):

#+BEGIN_SRC emacs-lisp
  (add-hook 'sql-interactive-mode-hook
            (lambda ()
              ;; (toggle-truncate-lines t)))
              (setq truncate-lines t)))
#+END_SRC

# And that table formating is not off when using =sql-send-region= to
# execute a query in a SQLi buffer (because the column names are printed
# on the same row as the the prompt). We [[https://www.emacswiki.org/emacs/SqlMode][simply add a newline]] before the
# comint output (for all queries, even queries run at the prompt):

# #+BEGIN_SRC emacs-lisp
#   ;; (defvar sql-last-prompt-pos 1
#   ;;   "position of last prompt when added recording started")
#   ;; (make-variable-buffer-local 'sql-last-prompt-pos)
#   ;; (put 'sql-last-prompt-pos 'permanent-local t) 
#   ;; (defun sql-add-newline-first (output)
#   ;;   "Add newline to beginning of OUTPUT for `comint-preoutput-filter-functions'
#   ;;   This fixes up the display of queries sent to the inferior buffer
#   ;;   programatically."
#   ;;   (let ((begin-of-prompt
#   ;;          (or (and comint-last-prompt-overlay
#   ;;                   ;; sometimes this overlay is not on prompt
#   ;;                   (save-excursion
#   ;;                     (goto-char (overlay-start comint-last-prompt-overlay))
#   ;;                     (looking-at-p comint-prompt-regexp)
#   ;;                     (point)))
#   ;;              1)))
#   ;;     (if (> begin-of-prompt sql-last-prompt-pos)
#   ;;         (progn
#   ;;           (setq sql-last-prompt-pos begin-of-prompt)
#   ;;           (concat "\n" output))
#   ;;       output))) 
#   ;; (defun sqli-add-hooks ()
#   ;;   "Add hooks to `sql-interactive-mode-hook'."
#   ;;   (add-hook 'comint-preoutput-filter-functions
#   ;;             'sql-add-newline-first)) 
#   ;; (add-hook 'sql-interactive-mode-hook 'sqli-add-hooks)
# #+END_SRC


** Web

[[http://web-mode.org/][Web-mode]] is a major mode to edit Web files ([s]HTML, CSS, PHP,
etc.). Here is a standard configuration, with auto-pairing, CSS
colorization and a broad list of file extensions and engines
associated to =web-mode=:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.htm?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.shtml?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.css\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.jinga\\'" . web-mode))
  (setq
   web-mode-enable-auto-pairing t
   web-mode-enable-css-colorization t
   web-mode-engines-alist
   '(("php"    . "\\.phtml\\'")
     ("django" . "\\.jinja\\'")
     ("blade"  . "\\.blade\\.")))
#+END_SRC

Spell check with flyspell can be further [[http://blog.binchen.org/?p=950][integrated to web-mode]]:

#+BEGIN_SRC emacs-lisp
  (defun web-mode-flyspell-verify ()
    (let* ((f (get-text-property (- (point) 1) 'face))
	   rlt)
      (cond
       ;; Check the words with these font faces, possibly.
       ;; this *blacklist* will be tweaked in next condition
       ((not (memq f '(web-mode-html-attr-value-face
                       web-mode-html-tag-face
                       web-mode-html-attr-name-face
                       web-mode-constant-face
                       web-mode-doctype-face
                       web-mode-keyword-face
                       web-mode-comment-face ;; focus on get html label right
                       web-mode-function-name-face
                       web-mode-variable-name-face
                       web-mode-css-property-name-face
                       web-mode-css-selector-face
                       web-mode-css-color-face
                       web-mode-type-face
                       web-mode-block-control-face)))
	(setq rlt t))
       ;; check attribute value under certain conditions
       ((memq f '(web-mode-html-attr-value-face))
	(save-excursion
	  (search-backward-regexp "=['\"]" (line-beginning-position) t)
	  (backward-char)
          (setq rlt (string-match "^\\(value\\|class\\|ng[A-Za-z0-9-]*\\)$"
                                  (thing-at-point 'symbol)))))
       ;; finalize the blacklist
       (t
	(setq rlt nil)))
      rlt))
  (put 'web-mode 'flyspell-mode-predicate 'web-mode-flyspell-verify)
#+END_SRC


** Polymode

[[https://github.com/vitoshka/polymode][Polymode]] allows multiple major modes in the same document (e.g. R +
Markdown in =.Rmd= files). It is setup for Mardown and LateX files
with R:

#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'auto-mode-alist '("\\.md" . poly-markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.[rR]md" . poly-markdown+r-mode))
  (add-to-list 'auto-mode-alist '("\\.[sS]nw" . poly-noweb+r-mode))
  (add-to-list 'auto-mode-alist '("\\.[rR]nw" . poly-noweb+r-mode))
  (add-to-list 'auto-mode-alist '("\\.org" . poly-org-mode))
#+END_SRC

# Diminish them?
# (with-eval-after-load 'poly-markdown-mode (diminish 'poly-markdown-mode))
# (with-eval-after-load 'poly-markdown+r-mode (diminish 'poly-markdown+r-mode))
# (with-eval-after-load 'poly-noweb+r-mode (diminish 'poly-noweb+r-mode))

Navigate through chunks: ~C-PageUp~ / ~C-PageDown~ go to previous/next
chunk; ~C-S-PageUp~ / ~C-S-PageDown~ go to previous/next chunk of the
same type:

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'polymode
    (define-key polymode-mode-map [(C-prior)] #'polymode-previous-chunk)
    (define-key polymode-mode-map [(C-next)] #'polymode-next-chunk)
    (define-key polymode-mode-map [(C-S-prior)] #'polymode-previous-chunk-same-type)
    (define-key polymode-mode-map [(C-S-next)] #'polymode-next-chunk-same-type))
#+END_SRC

# (setq 
# 	pm-weaver "knitR-ESS"		; Default weaver
# 	pm-exporter "pandoc")		; Default exporter
# (bind-keys :map polymode-mode-map
# 		  ([(f8)] . polymode-weave)       ; F7 to weave
# 		  ([(C-f8)] . polymode-export)))) ; C-F7 to export


* Postface

Of course, the very last part of this =init.org= file is the very
function that enables Emacs to regenerate both =init.el= and
=init.elc= files every time the =init.org= file is saved:

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are
  tangled, and the tangled file is compiled."
    (when (equal (buffer-file-name)
                 (expand-file-name (concat user-emacs-directory "init.org")))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
        (org-babel-tangle)
        (byte-compile-file (concat user-emacs-directory "init.el")))))
  
  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC
