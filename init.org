#+TITLE: Emacs literate configuration 
#+AUTHOR: Mathieu Basille
#+EMAIL: basille@ufl.edu
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes


* Table of Contents                                            :TOC:
 - [[#emacs-packages][Emacs packages]]
 - [[#interface][Interface]]
   - [[#color-theme][Color theme]]
   - [[#frames][Frames]]
   - [[#windows][Windows]]
   - [[#buffers][Buffers]]
   - [[#mode-line][Mode line]]
   - [[#minibuffer][Minibuffer]]
 - [[#buffer-editing][Buffer editing]]
   - [[#spell-check-and-syntax-check][Spell check and syntax check]]
   - [[#file-saving][File saving]]
 - [[#utilities][Utilities]]
   - [[#file-manager][File manager]]
   - [[#git][GIT]]
   - [[#shell][Shell]]
   - [[#pdf][PDF]]
   - [[#additional-functions][Additional functions]]
 - [[#major-modes][Major modes]]
   - [[#polymode][Polymode]]
   - [[#org][Org]]
   - [[#latex][LaTeX]]
   - [[#markdown][Markdown]]
   - [[#ess][ESS]]
   - [[#sql][SQL]]
   - [[#web][Web]]
 - [[#postface][Postface]]

* Emacs packages

Emacs now provide an entire ecosystem of packages, in various
repositories, and handles them through the =package= utility.  Emacs
packages can come from different repositories. We only activate the
official GNU repository, as well as [[http://melpa-stable.milkbox.net/][MELPA-stable]]:

#+BEGIN_SRC emacs-lisp
  (setq package-archives 
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa-stable" . "https://stable.melpa.org/packages/")
          ("melpa" . "https://melpa.org/packages/")
          ("org" . "http://orgmode.org/elpa/")
          )
        package-archive-priorities
        '(("org"          . 20)
          ("melpa-stable" . 10)
          ("gnu"          . 5)
          ("melpa"        . 0)
          ))
#+END_SRC

We now load it and make sure Emacs does not load it automatically 
a second time at startup, after all configuration is loaded:

#+BEGIN_SRC emacs-lisp
  (package-initialize)
  (setq package-enable-at-startup nil)
#+END_SRC

We can now automatically install the packages that are not in Debian
repositories. We first list these packages:

#+BEGIN_SRC emacs-lisp
  (setq package-list '(
                       aggressive-indent
                       anzu
                       auctex
                       auctex-latexmk
                       col-highlight
                       company
                       company-auctex
                       color-theme-sanityinc-tomorrow 
                       diminish
                       eshell-git-prompt
                       ess
                       ess-smart-underscore
                       expand-region
                       flx-ido
                       format-sql
                       hideshow-org
                       highlight 
                       highlight-indent-guides
                       ido-completing-read+
                       ido-ubiquitous
                       ido-vertical-mode
                       magit
                       magit-gitflow
                       markdown-mode
                       markdown-toc
                       multiple-cursors
                       pdf-tools
                       polymode
                       project-explorer
                       projectile
                       org
                       org-bullets
                       powerline
                       smex
                       sql-indent
                       sqlup-mode
                       toc-org
                       web-mode
                       yaml-mode
                       ))
#+END_SRC

Then fetch the list of packages available and install the missing
packages:

#+BEGIN_SRC emacs-lisp
  (unless package-archive-contents
    (package-refresh-contents))
  (dolist (package package-list)
    (unless (package-installed-p package)
      (package-install package)))
#+END_SRC

From now on, given that all packages are installed with a purpose,
Emacs will silently accept redefinitions of functions by packages (for
instance, =ido-ubiquitous= redefine =ido-completing-read= from =ido=):

#+BEGIN_SRC emacs-lisp
  (setq ad-redefinition-action 'accept)
#+END_SRC


* Interface


** Color theme

Use the theme [[https://github.com/purcell/color-theme-sanityinc-tomorrow][Tomorrow-eighties]] for Emacs GUI, and [[https://github.com/bbatsov/zenburn-emacs][Zenburn]] for Emacs
in the terminal:

#+BEGIN_SRC emacs-lisp
  (if (display-graphic-p) 
      (load-theme 'sanityinc-tomorrow-eighties t)
    (load-theme 'zenburn t))
#+END_SRC


** Frames

Frames (generally called windows) have a title instead of
=emacs25@<computer>=:

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '(buffer-file-name "Emacs: %b (%f)" "Emacs: %b"))
#+END_SRC


** Windows

Emacs starts split horizontaly in the middle:

#+BEGIN_SRC emacs-lisp
  (split-window-horizontally)
#+END_SRC

Open a file in the other window:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-r") 'ido-find-file-other-window)
#+END_SRC

Use ~M-<arrows>~ to move between windows (package =windmove=, built in
Emacs):

#+BEGIN_SRC emacs-lisp
  (windmove-default-keybindings 'meta)
#+END_SRC

Next window with ~C-~~ (key above TAB):

#+BEGIN_SRC emacs-lisp
  (global-set-key [C-dead-grave] 'other-window)
#+END_SRC

Mouse wheel does not accelerate:

#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-progressive-speed nil)
#+END_SRC

Scroll 2 lines from the edge:

#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 2)
#+END_SRC

Prevent lateral scrolling from touchpad to beep:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<mouse-7>")
                  (lambda () (interactive)))
  (global-set-key (kbd "<mouse-6>")
                  (lambda () (interactive)))
#+END_SRC

Visible bells (flashes the frame):

#+BEGIN_SRC emacs-lisp
  visible-bell t
#+END_SRC


** Buffers

Disable the splash screen:

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
#+END_SRC

Lines soft wrapped at word boundary (with fringe indicators):

#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode 1)
  (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
#+END_SRC

~F10~ to toggle line wrapping (activated by default):

#+BEGIN_SRC emacs-lisp
  (global-set-key [(f10)] 'toggle-truncate-lines)
#+END_SRC

Highlight columns ([[https://www.emacswiki.org/emacs/col-highlight.el][col-highlight]]): ~C-F10~ to toggle column highlight
mode.

#+BEGIN_SRC emacs-lisp
  (global-set-key [(ctrl f10)] 'column-highlight-mode)
#+END_SRC

Highlight regions ([[https://www.emacswiki.org/emacs/highlight.el][highlight]]): ~F9~ to highlight, ~C-F9~ to move to
the next highlighted text, ~C-S-F9~ to unhighlight everything.

#+BEGIN_SRC emacs-lisp
  (global-set-key [(f9)] 'hlt-highlight)
  (global-set-key [(ctrl f9)] 'hlt-next-highlight)
  (global-set-key [(ctrl shift f9)] 'hlt-unhighlight-region)
#+END_SRC

Highlight indentation in Programming mode (=highlight-indent-guides=):

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
  (setq highlight-indent-guides-method 'character) ; use 'column for more visible guides
#+END_SRC

Count words in region using ~C-+~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-+") 'count-words)
#+END_SRC

Kill THIS buffer with ~C-x k~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC


*** Navigation

Backward search with ~C-S-s~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-s") 'isearch-backward)
  (define-key isearch-mode-map (kbd "C-S-s") 'isearch-repeat-backward)
#+END_SRC

[[https://github.com/magnars/expand-region.el][Expand region]] with ~C-=~ (then continue to expand by pressing ~=~ or
contract by pressing ~-~):

#+BEGIN_SRC emacs-lisp
  ;;  (require 'expand-region)
#+END_SRC

[[https://github.com/shanecelis/hideshow-org][HideShow]] (fold or unfold functions/regions with ~TAB~ or ~C-S-F10~ if
the code is already indented) for Programming mode:

#+BEGIN_SRC emacs-lisp
  (require 'hideshow-org)
  (add-hook 'prog-mode-hook
            (lambda()
              (hs-org/minor-mode)
              (diminish 'hs-minor-mode)
              (local-set-key [(ctrl shift f10)] 'hs-toggle-hiding)
              ))
#+END_SRC

Saveplace: Go back to last position where the point was in a file
(save positions in =.emacs.d/cache/saved-places=):

#+BEGIN_SRC emacs-lisp
  (save-place-mode 1)
  (setq save-place-file "~/.emacs.d/cache/saved-places")
#+END_SRC

Use position registers (a sort of bookmark) with ~F1—F4~: ~C-F1~ to
~C-F4~ to save a register, ~F1~ to ~F4~ to jump to a saved register:

#+BEGIN_SRC emacs-lisp
  (global-set-key [(f1)]
                  '(lambda () (interactive) (jump-to-register 1 nil)))
  (global-set-key [(ctrl f1)]
                  '(lambda () (interactive) (point-to-register 1 nil)))
  (global-set-key [(f2)]
                  '(lambda () (interactive) (jump-to-register 2 nil)))
  (global-set-key [(ctrl f2)]
                  '(lambda () (interactive) (point-to-register 2 nil)))
  (global-set-key [(f3)]
                  '(lambda () (interactive) (jump-to-register 3 nil)))
  (global-set-key [(ctrl f3)]
                  '(lambda () (interactive) (point-to-register 3 nil)))
  (global-set-key [(f4)]
                  '(lambda () (interactive) (jump-to-register 4 nil)))
  (global-set-key [(ctrl f4)]
                  '(lambda () (interactive) (point-to-register 4 nil)))
#+END_SRC

Imenu lists the main parts of a document (sections, headers, etc.) to
navigate interactively a long document (bound to ~C-M-=~):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-M-=") #'imenu)
#+END_SRC


** Mode line

Use a Power line:

#+BEGIN_SRC emacs-lisp
  (powerline-default-theme)
#+END_SRC

Display line and column number in the mode line:

#+BEGIN_SRC emacs-lisp
  (column-number-mode 1)
#+END_SRC

[[https://github.com/syohex/emacs-anzu][Anzu]]: display current match and total matches information in the
mode-line, and show replacement interactively. Replace is bound to
~C-r~, and replace using a RegExp is bound to ~C-M-r~:

#+BEGIN_SRC emacs-lisp
  (global-anzu-mode 1)
  (anzu-mode 1)
  (with-eval-after-load 'anzu (diminish 'anzu-mode))
  (global-set-key (kbd "C-r") 'anzu-query-replace)
  (global-set-key (kbd "C-M-r") 'anzu-query-replace-regexp)
#+END_SRC


"Diminish" =auto-fill= (automatically break long lines while typing),
=auto-revert= (which is used by Magit to automatically update file
content), =visual-line-mode= (word wrapping at the end of long lines),
=eldoc= (display function arguments in the minibuffer), Lisp
Interaction (replaced with just "Lisp"):

#+BEGIN_SRC emacs-lisp
  (diminish 'auto-fill-function)
  (diminish 'auto-revert-mode)
  (diminish 'visual-line-mode)
  (diminish 'eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook 
            (lambda()
              (setq mode-name "Lisp"))) 
#+END_SRC


** Minibuffer

Answer with y/n instead of yes/no:

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Enhanced ~M-x~: SMEX, with states saved in the =cache= subfolder (note
that the "old" =M-x= is the command =execute-extended-command=):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)
  (setq smex-save-file "~/.emacs.d/cache/smex-items")
#+END_SRC


*** IDO: Interactively Do Things

[[https://www.gnu.org/software/emacs/manual/ido.html][IDO]] allows to Interactively Do Things, more precisely to give
interactively lists of possibilities when opening a file, executing a
function, etc. (note that it is possible to fall back to a normal
prompt using ~C-f~).

Initialize it, and make it work everywhere:

#+BEGIN_SRC emacs-lisp
  (ido-mode 1)
  (ido-everywhere 1)
#+END_SRC

Set up IDO with almost anything that uses completion:

#+BEGIN_SRC emacs-lisp
  (ido-ubiquitous-mode 1)
#+END_SRC

Use IDO in vertical mode:

#+BEGIN_SRC emacs-lisp
  (ido-vertical-mode 1)
#+END_SRC

Use "flex" matching (i.e. typing a few characters will select items
containing these characters in the given order, but not necessarily in
a sequence) with =flx-ido=:

#+BEGIN_SRC emacs-lisp
  (flx-ido-mode 1)
#+END_SRC

Other settings: IDO uses flexible matching, find file at point
intelligently, always create new buffers with ~C-x b~, and saves its
state in the =cache= folder:

#+BEGIN_SRC emacs-lisp
  (setq
   ido-use-filename-at-point 'guess
   ido-create-new-buffer 'always
   ;; ido-file-extensions-order '(".Rmd" ".R" ".tex" ".el") ; extension order
   ido-save-directory-list-file "~/.emacs.d/cache/ido")
#+END_SRC

Cycle through buffers with =IDO= (~C-TAB~ in this window and ~C-S-TAB~
in the other window):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<C-tab>") 'ido-switch-buffer)
  (global-set-key (kbd "<C-iso-lefttab>") 'ido-switch-buffer-other-window) ; C-S-TAB
#+END_SRC


* Buffer editing

Never use Tabs when indenting, use spaces instead:

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

Delete selection mode (replace a selection):

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

Undo with ~C-z~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-z") 'undo)
#+END_SRC

Electric pair mode: Automatically close double quotes, back quotes,
parentheses, square brackets and curly brackets:

#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)
  (setq electric-pair-pairs '(
                              (?\" . ?\")
                              (?\` . ?\`)
                              (?\( . ?\))
                              (?\[ . ?\])
                              (?\{ . ?\})
                              ) )
#+END_SRC

Show matching parentheses and other characters (without any delay):

#+BEGIN_SRC emacs-lisp
  (setq show-paren-delay 0)
  (show-paren-mode 1)
#+END_SRC

[[https://github.com/Malabarba/aggressive-indent-mode][Aggressive indent]] in Programming mode to indent automatically all
blocks when a part is moved (add modes to
=aggressive-indent-excluded-modes= to NOT start aggressive indent in
this mode):

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook #'aggressive-indent-mode)
#+END_SRC

Automatically break long lines (by default after 70 characters, as set
in the variable =fill-column=): 

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC

Consider CamelCase as two words in programming modes (but don't show
it with "," in the mode line):

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'subword-mode)
  (with-eval-after-load 'subword (diminish 'subword-mode))
#+END_SRC

Complete anything (=company=), with ~TAB~ (=(kbd "TAB")= for terminal;
=[tab]= for graphical mode) to complete immediately, no delay and
aggressive completion:

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'global-company-mode)
  (with-eval-after-load 'company
    (define-key company-active-map (kbd "TAB") #'company-complete-common)
    (define-key company-active-map [tab] #'company-complete-common)
    (diminish 'company-mode))
  (setq company-idle-delay 0
        company-echo-delay 0
        company-dabbrev-downcase nil
        company-minimum-prefix-length 2
        company-selection-wrap-around t
        company-transformers '(company-sort-by-occurrence
                               company-sort-by-backend-importance))
#+END_SRC

Multiple cursors (=multiple-cursors=), choices are saved in the
=cache= folder; ~F11~ to have multiple cursors in all lines of a
region; ~C-F11~ tries to be smart about marking everything you want
(can be pressed multiple times); ~C-S-F11~ marks the next item like
the selection (use then arrows to select more/less):

#+BEGIN_SRC emacs-lisp
  (setq mc/list-file "~/.emacs.d/cache/mc-lists.el")
  (global-set-key [(f11)] 'mc/edit-lines)
  (global-set-key [(ctrl f11)] 'mc/mark-all-dwim)
  (global-set-key [(ctrl shift f11)] 'mc/mark-more-like-this-extended)
#+END_SRC


** Spell check and syntax check

Emacs built-in spell check package is Ispell. A good approach is to
use =Hunspell= as the spell check engine (needs to be installed), with
"en_US" as the default dictionary (~C-S-F12~ to change
dictionary). =Flyspell= (spell check on the fly) is enabled by default
in all text files (~C-F12~ to toggle Flyspell), and in programming
mode (only in the comments) in programming files. ~F12~ (or middle
click) opens the list of correction suggestions:

#+BEGIN_SRC emacs-lisp
  (setq ispell-program-name "hunspell"
        ispell-local-dictionary "en_US")

  (add-hook 'text-mode-hook 'turn-on-flyspell)
  (add-hook 'prog-mode-hook 'flyspell-prog-mode)

  (global-set-key [f12] 'flyspell-correct-word-before-point)
  (global-set-key [C-f12] 'flyspell-mode) ; + flyspell-buffer when on!
  (global-set-key [C-S-f12] 'ispell-change-dictionary)
#+END_SRC


** File saving

Default language environment is UTF-8:

#+BEGIN_SRC emacs-lisp
  (setq current-language-environment "UTF-8")
#+END_SRC

Don't lock files and accepts simultaneous editing (no [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Interlocking.html][interlocking]],
which creates tmp lockfiles):

#+BEGIN_SRC emacs-lisp
  (setq create-lockfiles nil)
#+END_SRC

[[http://www.emacswiki.org/emacs/AutoSave][Auto-save]] in =~/.emacs.d/save= (after 10 seconds or 100 characters):

#+BEGIN_SRC emacs-lisp
  (setq
   auto-save-file-name-transforms `((".*" ,"~/.emacs.d/save/\\1" t))
   auto-save-list-file-name "~/.emacs.d/cache/save-list"
   auto-save-interval 100
   auto-save-timeout 10)
#+END_SRC

[[http://www.emacswiki.org/emacs/BackupDirectory][Backups]] in =~/.emacs.d/save= (a backup happens everytime a file is
open, and then on each subsequent saves). Copy backup files, keep a
versioned (numbered) backup, and only keep the first 2 and last 2
versions of each backup:

#+BEGIN_SRC emacs-lisp
  (setq
   backup-directory-alist `((".*" . "~/.emacs.d/save"))
   backup-by-copying t
   version-control t
   kept-new-versions 2
   kept-old-versions 2
   delete-old-versions t)
#+END_SRC

Abbreviations ([[https://www.gnu.org/software/emacs/manual/html_node/emacs/Abbrevs.html][Abbrevs]]) are a way to save keystrokes by expanding
words into longer text. Since I don't use it, it gets slightly in the
way. I tell Emacs to save abbreviations in the cache directory
silently:

#+BEGIN_SRC emacs-lisp
  (setq abbrev-file-name "~/.emacs.d/cache/abbrev_defs")
  (setq save-abbrevs 'silently)
#+END_SRC


* Utilities


** File manager

=Dired= list directories first:

#+BEGIN_SRC emacs-lisp
  (setq dired-listing-switches "-aBhl  --group-directories-first")
#+END_SRC

Manage projects with [[http://batsov.com/projectile/][projectile]] and [[https://github.com/sabof/project-explorer][project-explorer]] (the later bound
to ~F5~). Project-explorer is set to a width of 20 characters, and
saves its cache in the =cache= folder:

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode +1)
  (setq projectile-known-projects-file "~/.emacs.d/cache/projectile-bookmarks.eld")
  (diminish 'projectile-mode "Proj")
  (setq pe/width 20)
  (setq pe/cache-directory "~/.emacs.d/cache/project-explorer-cache/")
  (global-set-key [(f5)] 'project-explorer-toggle)
#+END_SRC


** GIT

[[https://magit.vc/][Magit]] is a interface to Git completely integrated to Emacs. Once
installed, it pretty much works out of the box, there are just a
couple of settings to make it even smoother (remove Git from the list
of backends handled by Emacs version control; use IDO to complete;
links to Git-man; automatically refresh the repository's status after
file save). We also bound Magit to ~F6~, and integrate Git-flow to
Magit (=magit-gitflow=, started with ~C-f~ from within Magit):

#+BEGIN_SRC emacs-lisp
  (global-set-key [(f6)] 'magit-status)
  (setq vc-handled-backends (delq 'Git vc-handled-backends))
  (setq magit-completing-read-function 'magit-ido-completing-read)
  (setq magit-view-git-manual-method 'man)
  (with-eval-after-load 'magit
    (add-hook 'after-save-hook 'magit-after-save-refresh-status))
  (add-hook 'magit-mode-hook 'turn-on-magit-gitflow)
#+END_SRC

** Shell

Emacs provide different possibilities to embed a Shell (for instance,
~M-x shell~, ~M-x ansi-term~), with different advantages and
drawbacks. Here I setup Eshell (the Emacs shell, ~M-x eshell~, bound
to ~F7~), with short names to [[https://www.emacswiki.org/emacs/EshellRedirection][redirect to buffers]] and completion that
ignores case. [[https://github.com/xuchunyang/eshell-git-prompt][eshell-git-prompt]] enables detection of Git repositories
and brings a nice powerline:

#+BEGIN_SRC emacs-lisp
  (global-set-key [(f7)] 'eshell)
  (setq
   eshell-buffer-shorthand t
   eshell-cmpl-ignore-case t)
  (eshell-git-prompt-use-theme 'powerline)
#+END_SRC

** PDF

Use PDF tools to view PDF (=libpoppler-glib-dev= required):

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.pdf" . pdf-tools-install))
#+END_SRC

From within a PDF, use ~P~ to fit the zoom to the page; ~H~ to
the height, ~W~ to the width; ~g~ refreshes (reverts) the PDF; ~h~
opens the help of PDF tools.


** Additional functions

# ;; Additional functions (.el)
# ;; 
# ;; Functions are in ~/.emacs.d/functions/
# (add-to-list 'load-path "~/.emacs.d/functions/")

# ;; C-S-F3/F4 to prepare the code for Dotclear to insert a photo:
# (load-library "dc-insert")
# (global-set-key [(ctrl shift f3)] 'dc-insert-photos)
# (global-set-key [(ctrl shift f4)] 'dc-insert-videos)
# ;; ;; C-F8 to start a Shell on Beheaded (ssh Beheaded) with screen capability:
# ;; (load-library "shell-beheaded")
# ;; (global-set-key [(ctrl f8)] 'shell-beheaded)


* Major modes


** Polymode

[[https://github.com/vitoshka/polymode][Polymode]] allows multiple major modes in the same document (e.g. R +
Markdown in =.Rmd= files). It is setup for Mardown and LateX files
with R:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.md" . poly-markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.Rmd" . poly-markdown+r-mode))
  (add-to-list 'auto-mode-alist '("\\.Snw" . poly-noweb+r-mode))
  (add-to-list 'auto-mode-alist '("\\.Rnw" . poly-noweb+r-mode))
  (add-to-list 'auto-mode-alist '("\\.org" . poly-org-mode))
#+END_SRC

  # Diminish them?
  # (with-eval-after-load 'poly-markdown-mode (diminish 'poly-markdown-mode))
  # (with-eval-after-load 'poly-markdown+r-mode (diminish 'poly-markdown+r-mode))
  # (with-eval-after-load 'poly-noweb+r-mode (diminish 'poly-noweb+r-mode))



  # (setq 
     # 	pm-weaver "knitR-ESS"		; Default weaver
        # 	pm-exporter "pandoc")		; Default exporter
  # (bind-keys :map polymode-mode-map
	       # 		  ([(C-prior)] . polymode-previous-chunk) ; C-PageUp to move to the previous chunk (code or comment)
                                  # 		  ([(C-next)] . polymode-next-chunk)      ; C-PageDown to move to the next chunk (code or comment)
                                                  # 		  ([(C-S-prior)] . polymode-previous-chunk-same-type) ; C-S-PageUp to move to the previous chunk of the same type
                                                                  # 		  ([(C-S-next)] . polymode-next-chunk-same-type)      ; C-S-PageDown to move to the next chunk of the same type
                                                                                  # 		  ([(f8)] . polymode-weave)       ; F7 to weave
                                                                                                  # 		  ([(C-f8)] . polymode-export)))) ; C-F7 to export




  ** YAML

  =YAML-mode= for YAML headers/files:

  #+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
    #+END_SRC


** Org



Org mode comes with its own keybindings, ([[http://orgmode.org/manual/Conflicts.html][which can easily conflict
with other settings]]).

#+BEGIN_SRC emacs-lisp
  (setq org-replace-disputed-keys t)
  #+END_SRC

Make nice UTF-8 bullet points:

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC

# [not working]
#
# To make windmove active in locations where Org mode does not have
# special functionality on M-<cursor>:
#
# #+BEGIN_SRC emacs-lisp
# (add-hook 'org-metaup-final-hook 'windmove-up)
# (add-hook 'org-metaleft-final-hook 'windmove-left)
# (add-hook 'org-metadown-final-hook 'windmove-down)
# (add-hook 'org-metaright-final-hook 'windmove-right)
# #+END_SRC


Table of contents with [[https://github.com/snosov1/toc-org][Toc-Org]] (just add a =:TOC:= tag with 
~C-c C-q~ in the first header, and the table of contents will be
automatically updated on file save):

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'toc-org-enable)
#+END_SRC


Org-babel can recognize code blocks [[http://orgmode.org/manual/Languages.html][from many different languages]] (Lisp,
Bash, R, etc.) and provides a way to edit them in their respective
mode (~C-c '~; and same keybinding to close). However,  =polymode=
provides an even better integration directly in the Org file. We load
a few languages:

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((css . t)
       (ditaa . t)
       (emacs-lisp . t)
       (latex . t)
       (lilypond . t)
       (org . t)
       (sh . t)
       (sql . t)
       (R . t))))
  #+END_SRC


# ;; Keeping notes and TODO lists: org-mode
# (use-package org
# 	     ;; See config at: http://writequit.org/org/settings.html#sec-1-6x
# 	     :mode (("\\.org$" . org-mode))	; Activate Org for .org files
# 	     :bind (("C-c l" . org-store-link)
# 		    ("C-c a" . org-agenda)
# 		    ("C-c b" . org-iswitchb)
# 		    ("C-c c" . org-capture)
# 		    ("C-c M-p" . org-babel-previous-src-block)
# 		    ("C-c M-n" . org-babel-next-src-block)
# 		    ("C-c S" . org-babel-previous-src-block)
# 		    ("C-c s" . org-babel-next-src-block)
# 		    ([(f6)] . org-todo-list) ; Global TODO list
# 		    ([(control f6)] . org-ctrl-c-ctrl-c) ; C-c C-c 
# 		    ([(f7)] . org-insert-todo-here) ; Insert TODO at point
# 		    ([(control f7)] . org-todo)	 ; Rotate TODO state
# 		    ([(control shift f7)] . org-show-todo-tree)	 ; Shows TODOs in current buffer
# 		    ;; (:map org-mode-map		  ; Edit code block in its specific mode
# 		    ;;       ([(control shift f6)] . org-edit-special))
# 		    ;; (:map org-src-mode-map		; Exit code block editing
# 		    ;;       ([(control shift f6)] . org-edit-srv-exit))
# 		    )
# 	     :config
# 	     (progn
# 	       (org-defkey org-mode-map [(ctrl shift f6)] 'org-edit-special) ; Edit code block in its specific mode
# 	       (org-defkey org-src-mode-map [(ctrl shift f6)] 'org-edit-src-exit) ; Exit code block editing
# 	       (setq
# 		;; Display
# 		org-hide-emphasis-markers t	; Hide markers
# 		org-ellipsis "⤵"			; Downward-pointing arrow instead of the usual …
# 		org-src-fontify-natively t		; Use syntax highlighting in source blocks
# 		org-src-tab-acts-natively t	; Make TAB act like the language's major mode in source blocks
# 		;; org-startup-folded 'overview ; Start with top level headlines visible
# 		org-display-inline-images t	; Enable inline images
# 		;; org-directory 			; Where Org checks for files
# 		;; org-archive-location		; Folder for archiving an entry
# 		org-agenda-files '("~/.emacs.d/org") ; List of files for agenda/TODOs
# 		;; org-support-shift-select 'always	; Allows shift selection
# 		org-return-follows-link t		; Follow links by pressing ENTER on them
# 					; (alternative to C-c C-o / M-x org-open-at-point)
# 		org-replace-disputed-keys t	; Conflicting keys
# 					; http://orgmode.org/manual/Conflicts.html
# 		org-default-notes-file (concat org-directory "/notes.org")
# 					;
# 		org-log-done t		   ; Insert dates for changes in TODOs
# 		org-todo-keywords ; TODO keywords: http://orgmode.org/manual/TODO-extensions.html#TODO-extensions
# 					; http://orgmode.org/guide/Tracking-TODO-state-changes.html#Tracking-TODO-state-changes
# 					; @ requires a note
# 					; ! puts a timestamp (not necessary for DONE)
# 		;; '((sequence "SOMEDAY(s)" "NOW(n)" "LATER(l)" "WAITING(w@/!)" "NEEDSREVIEW(n@/!)" "|" "DONE(d)")
# 		'((sequence "SOMEDAY(s)" "NOW(n!)" "LATER(l)" "PROJECT(p)" "CANCELLED(c@/!)" "|" "DONE(d)"))
# 		;; (sequence "REPORT(r)" "BUG(b)" "KNOWNCAUSE(k)" "|" "FIXED(f)"))
# 		org-todo-keyword-faces		; ORG faces
# 		'(("SOMEDAY" :foreground "purple" :weight bold)
# 		  ("NOW" :foreground "orange" :weight bold)
# 		  ("LATER" :foreground "forest green" :weight bold)
# 		  ("PROJECT" :foreground "blue" :weight bold)
# 		  ("CANCELLED" :foreground "red" :weight bold)
# 		  ("DONE" :foreground "gray" :weight bold))
# 		org-use-fast-todo-selection t	; Menu with selection of TODO keywords
# 		org-enforce-todo-dependencies t	; Parent can't be marked as done unless all children are done
# 		org-ditaa-jar-path (expand-file-name "/usr/share/ditaa/ditaa.jar") ; Path to ditaa.jar
# 		)
# 	       (defun org-summary-todo (n-done n-not-done)
# 		 "Switch entry to DONE when all subentries are done, to SOMEDAY otherwise."
# 		 (let (org-log-done org-log-states)   ; turn off logging
# 		   (org-todo (if (= n-not-done 0) "DONE" "SOMEDAY"))))
# 	       ;; Insert TODO at point
# 	       (load-library "org-insert-todo-here")
# 	       ;; DISPLAY
# 	       (font-lock-add-keywords 'org-mode	; Real bullets
# 				       '(("^ +\\([-*+]\\) "
# 					  (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
# 	       ;; Nice headers
# 	       (let* ((variable-tuple (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
# 					    ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
# 					    ((x-list-fonts "Verdana")         '(:font "Verdana"))
# 					    ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
# 					    (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
# 		      (base-font-color     (face-foreground 'default nil 'default))
# 		      (headline           `(:inherit default :weight bold :foreground ,base-font-color)))
# 		 (custom-theme-set-faces 'user
# 					 `(org-level-8 ((t (,@headline ,@variable-tuple))))
# 					 `(org-level-7 ((t (,@headline ,@variable-tuple))))
# 					 `(org-level-6 ((t (,@headline ,@variable-tuple))))
# 					 `(org-level-5 ((t (,@headline ,@variable-tuple))))
# 					 `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
# 					 `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
# 					 `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
# 					 `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
# 					 `(org-document-title ((t (,@headline ,@variable-tuple :height 1.5 :underline nil))))))
# 	       (use-package org-bullets	; Header bullets
# 					; https://github.com/sabof/org-bullets
# 			    :config
# 			    (progn
# 			      (require 'org-bullets)		; 
# 			      (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))))
# 	       ))



** LaTeX


kpsewhich -show-path=.bib
should contain: /home/<user>/.texlive2016/texmf-var/bibtex/bib//
mkdir -p ~/.texlive2016/texmf-var/bibtex/bib
ln -s ~/Work/Biblio/ ~/.texlive2016/texmf-var/bibtex/bib

C-c -C-l to show compilation logs (=(setqTeX-show-compilation t)= to
have it by default)

pdf-sync-display-pdf (C-g) for forward search
Ctrl+click for inverse search

#+BEGIN_SRC emacs-lisp
  (setq TeX-parse-self t ; Enable parse on load.
        TeX-auto-save t ; Enable parse on save.
                                        ;        TeX-show-compilation t          ; Show compliation output
        TeX-source-correlate-mode t	; Forward and inverse search
        TeX-clean-confirm nil ; Don't ask for confirmation to clean intermediary files
        reftex-plug-into-AUCTeX t       ; Plug RefTeX to AUCTeX
        ;; reftex-default-bibliography '("~/Work/Biblio/BiblioMB.bib")
		        		; Define default bib file
        )
  (add-hook 'LaTeX-mode-hook 
            (lambda ()
              (TeX-global-PDF-mode t) ; Compile as PDF
              (LaTeX-math-mode)	; Math mode
              (turn-on-reftex)	; RefTeX on
              (outline-minor-mode 1)	; Fold LaTeX sections
              (TeX-fold-mode 1)	; Fold LaTeX environments
              ))
#+END_SRC

auctex-latexmk: Integration of LaTeXmk
https://github.com/tom-tan/auctex-latexkm

#+BEGIN_SRC emacs-lisp
  (setq auctex-latexmk-inherit-TeX-PDF-mode t) ; LaTeXMk inherits PDF mode
  (with-eval-after-load "tex"
    (auctex-latexmk-setup))
  (add-hook 'TeX-mode-hook '(lambda () (setq TeX-command-default "LatexMk"))) ; LaTeXMk default engine
#+END_SRC

Autocompletion using Company

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load "tex"
    (company-auctex-init))
#+END_SRC


Use PDF tools (and start Sync server) and refresh PDF automatically:

#+BEGIN_SRC emacs-lisp
  (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
        TeX-source-correlate-start-server t)

  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
#+END_SRC


# ;; Clean up intermediary files with LaTeXmk and Beamer
# (add-to-list 'LaTeX-clean-intermediate-suffixes "\\.fdb_latexmk" t)
# (add-to-list 'LaTeX-clean-intermediate-suffixes "\\.vrb" t)


** Markdown

[[http://jblevins.org/projects/markdown-mode/][Markdown-mode]] is used to edit Markdown files (=.md= or =.markdown=)
and is loaded automatically. We simply enable Math:

# BUG with markdown-toc; see bug report with M-x markdown-toc-bug-report
# 
# , and integrate
# =[[https://github.com/ardumont/markdown-toc][markdown-toc]]= (type ~M-x markdown-toc-generate-toc~ to generate Table
# of contents at point):

#+BEGIN_SRC emacs-lisp
  (setq markdown-enable-math t)
#+END_SRC


	       # (load-library "rmd-R-insert-code") ; In (R)Markdown, add a new R
	       # 				; chunk with C-return and
	       # 				; inline R code with C-S-return
	       # (add-hook 'markdown-mode-hook 
	       # 		 (lambda ()
	       # 		   (imenu-add-menubar-index) ; Add imenu
	       # 		   (local-set-key [C-return] 'rmd-R-fenced-code-block) ; C-return to 
	       # 				; insert a new R chunk
	       # 		   (local-set-key [C-S-return] 'rmd-R-inline-code)))) ; C-S-return to 
	       # 				; insert inline R code



** ESS

ESS to use R, edit R script, edit R documentation (Roxygen) and
prepare packages. ESS is simply loaded with:

[[https://github.com/mattfidler/ess-smart-underscore.el][ESS Smart Underscore]]

#+BEGIN_SRC emacs-lisp
  (require 'ess-site)
  (setq
                                        ; ess-default-style 'RRR+  ; Use RRR+ style
   inferior-ess-same-window nil         ; Run R in inferior window
   ess-ask-for-ess-directory nil ; Use current directory as working directory
   inferior-R-args "--quiet --no-save"  ; No save on exit
   ess-nuke-trailing-whitespace-p t     ; remove trailing spaces
   comint-scroll-to-bottom-on-input t ; Always scroll to the end of the R buffer
   comint-scroll-to-bottom-on-output t ; Scroll automatically when output reaches bottom
   ;; comint-move-point-for-output t
   ess-eval-visibly 'nowait             ; Does not wait for R
   ess-swv-processor 'knitr ; Use knitr instead of Sweave as ESS processor
   ess-roxy-fontify-examples t ; Syntax highlighting in Roxygen examples
   )
  #+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun myindent-ess-hook ()
    (setq 
     ess-indent-offset 4
     ess-offset-arguments 'prev-line
     ess-offset-arguments-newline 'prev-line
     ess-offset-block 'prev-line
     ess-offset-continued nil
     ess-align-nested-calls nil
     ess-align-arguments-in-calls nil
     ess-align-continuations-in-calls nil
     ess-align-blocks nil
     ess-indent-from-lhs nil
     ess-indent-from-chain-start nil
     ess-indent-with-fancy-comments t
     ))

  (add-hook 'ess-mode-hook 
            (lambda ()
              (flyspell-prog-mode)
              (require 'ess-smart-underscore)
              (highlight-indent-guides-mode) ; Highlight indentation using
                                        ; 'highlight-indent-guides'
              (subword-mode) ; Consider CamelCase as two words             
              (diminish 'hs-minor-mode)
              (hs-org/minor-mode) 
              (local-set-key [(ctrl shift f10)] 'hs-toggle-hiding)
              (aggressive-indent-mode)
              (myindent-ess-hook)
              (add-hook 'local-write-file-hooks ; Remove trailing white spaces on save
                        (lambda ()
                          (ess-nuke-trailing-whitespace)))
	      ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'ess-R-post-run-hook 
            'ess-execute-screen-options) ; Sets R option "width" to the width of the R 
                                        ; buffer on startup
#+END_SRC



    # (load-library "ess-indent-region-R") ; Use the R parser or formatR to format R code 
    # 					; (C-M-\ ou 'M-x indent-region')
    # 					; http://www.emacswiki.org/emacs/ESSRParser
    # (load-library "ess-swv-pandoc")	; Use knitr::pandoc with options in
    # 					; .emacs.d/config/config.pandoc
    # (defun ess-remote-r ()		; Associate R remote buffer to ESS buffer
    #   (interactive) (ess-remote nil "R"))
    # (bind-key "\C-cw" 'ess-execute-screen-options inferior-ess-mode-map) ; C-c w to adjust
    # 					; the width of the R buffer
    # (bind-keys :map ess-mode-map
    # 	 ("C-c C-x" . ess-eval-chunk)		; C-c C-x to evaluate a R chunk (C-c C-c 
    # 					; should jump to the next block and C-M-x evaluates
    # 					; and stays in place)
    # 	 ([(control shift f8)] . ess-swv-tangle)))) ; C-S-F7 to tangle
    # 	 ;; ([(f8)] . ess-display-vignettes)	 ; F8 to display the list of vignettes
    # 	 ;; ([(ctrl shift f8)] . ess-remote-r)))) ; C-S-F8 to associate R remote buffer to ESS buffer


** SQL

[[https://github.com/bsvingen/sql-indent][sql-indent]]

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'sql (load-library "sql-indent"))
#+END_SRC

[[https://github.com/Trevoke/sqlup-mode.el][SQL-up]]

Capitalize keywords in SQL mode
Capitalize keywords in an interactive session (e.g. psql)
sqlup on a region set to C-c u

#+BEGIN_SRC emacs-lisp
  (add-hook 'sql-mode-hook 'sqlup-mode)
  (add-hook 'sql-interactive-mode-hook 'sqlup-mode)
  (add-hook 'sql-mode-hook
            '(lambda ()
               (local-set-key (kbd "C-c u") 'sqlup-capitalize-keywords-in-region)))
#+END_SRC

format-sql (Python library) (an alternative is [[https://github.com/ldeck/SqlBeautify][SQL-beautify]])

$ sudo pip install format-sql

#+BEGIN_SRC emacs-lisp
  (add-hook 'sql-mode-hook
            '(lambda ()
               (local-set-key (kbd "C-M-]") 'format-sql-region)))
#+END_SRC

  # ;; (defun format-sql-region-or-buffer ()
  # ;;   "Format SQL for the entire buffer or the marked region"
  # ;;   (interactive)
  # ;;   (if (use-region-p)
  # ;;       (format-sql-bf--apply-executable-to-buffer "format-sql"
  # ;;                                                  'format-sql--call-executable
  # ;;                                                  t
  # ;;                                                  (get-file-type)))
  # ;;   (format-sql-bf--apply-executable-to-buffer "format-sql"
  # ;;                                              'format-sql--call-executable
  # ;;                                              nil
  # ;;                                              (get-file-type)))

# If only one server:

# #+BEGIN_SRC emacs-lisp
#   ;; (setq sql-postgres-login-params
#   ;;       '((server :default "localhost")
#   ;;         (port :default 5432)
#   ;;         (user :default "postgres")
#   ;;         (database :default "postgres")))
# #+END_SRC
  
# If several servers

# #+BEGIN_SRC emacs-lisp
#   ;; (setq sql-connection-alist
#   ;;       '((server1 (sql-product 'postgres)
#   ;;                  (sql-server "localhost")
#   ;;                  (sql-port 5432)
#   ;;                  (sql-user "user")
#   ;;                  (sql-password "password")
#   ;;                  (sql-database "db1"))
#   ;;         (server2 (sql-product 'postgres)
#   ;;                  (sql-server "localhost")
#   ;;                  (sql-port 5432)
#   ;;                  (sql-user "user")
#   ;;                  (sql-password "password")
#   ;;                  (sql-database "db2"))))
# #+END_SRC

No line truncate in results:

#+BEGIN_SRC emacs-lisp
  (add-hook 'sql-interactive-mode-hook
            (lambda ()
              (toggle-truncate-lines t))) 
#+END_SRC

When using sql-send-region to execute a query in a SQLi buffer, the table formatting is off because the column names are printed on the same row as the the prompt. By adding a newline before the comint output we can make sure everything lines up nice. This will add a preceding newline to every comint output, even queries run at the prompt - though the extra line isn’t too noticeable.

#+BEGIN_SRC emacs-lisp
  (defvar sql-last-prompt-pos 1
    "position of last prompt when added recording started")
  (make-variable-buffer-local 'sql-last-prompt-pos)
  (put 'sql-last-prompt-pos 'permanent-local t)
  
  (defun sql-add-newline-first (output)
    "Add newline to beginning of OUTPUT for `comint-preoutput-filter-functions'
    This fixes up the display of queries sent to the inferior buffer
    programatically."
    (let ((begin-of-prompt
           (or (and comint-last-prompt-overlay
                    ;; sometimes this overlay is not on prompt
                    (save-excursion
                      (goto-char (overlay-start comint-last-prompt-overlay))
                      (looking-at-p comint-prompt-regexp)
                      (point)))
               1)))
      (if (> begin-of-prompt sql-last-prompt-pos)
          (progn
            (setq sql-last-prompt-pos begin-of-prompt)
            (concat "\n" output))
        output)))
  
  (defun sqli-add-hooks ()
    "Add hooks to `sql-interactive-mode-hook'."
    (add-hook 'comint-preoutput-filter-functions
              'sql-add-newline-first))
  
  (add-hook 'sql-interactive-mode-hook 'sqli-add-hooks)
#+END_SRC



** Web

[[http://web-mode.org/][Web-mode]] is a major mode to edit Web files ([s]HTML, CSS, PHP,
etc.). Here is a standard configuration, with auto-pairing, CSS
colorization and a broad list of file extensions and engines
associated to =web-mode=:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.htm?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.shtml?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.css\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.jinga\\'" . web-mode))
  (setq
   web-mode-enable-auto-pairing t
   web-mode-enable-css-colorization t
   web-mode-engines-alist
   '(("php"    . "\\.phtml\\'")
     ("django" . "\\.jinja\\'")
     ("blade"  . "\\.blade\\.")))
#+END_SRC

Spell check with flyspell can be further [[http://blog.binchen.org/?p=950][integrated to web-mode]]:

#+BEGIN_SRC emacs-lisp
  (defun web-mode-flyspell-verify ()
    (let* ((f (get-text-property (- (point) 1) 'face))
	   rlt)
      (cond
       ;; Check the words with these font faces, possibly.
       ;; this *blacklist* will be tweaked in next condition
       ((not (memq f '(web-mode-html-attr-value-face
                       web-mode-html-tag-face
                       web-mode-html-attr-name-face
                       web-mode-constant-face
                       web-mode-doctype-face
                       web-mode-keyword-face
                       web-mode-comment-face ;; focus on get html label right
                       web-mode-function-name-face
                       web-mode-variable-name-face
                       web-mode-css-property-name-face
                       web-mode-css-selector-face
                       web-mode-css-color-face
                       web-mode-type-face
                       web-mode-block-control-face)))
	(setq rlt t))
       ;; check attribute value under certain conditions
       ((memq f '(web-mode-html-attr-value-face))
	(save-excursion
	  (search-backward-regexp "=['\"]" (line-beginning-position) t)
	  (backward-char)
          (setq rlt (string-match "^\\(value\\|class\\|ng[A-Za-z0-9-]*\\)$"
                                  (thing-at-point 'symbol)))))
       ;; finalize the blacklist
       (t
	(setq rlt nil)))
      rlt))
  (put 'web-mode 'flyspell-mode-predicate 'web-mode-flyspell-verify)
#+END_SRC


* Postface

Of course, the very last part of this =init.org= file is the very
function that enables Emacs to regenerate both =init.el= and
=init.elc= files every time the =init.org= file is saved:

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are
  tangled, and the tangled file is compiled."
    (when (equal (buffer-file-name)
                 (expand-file-name (concat user-emacs-directory "init.org")))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
        (org-babel-tangle)
        (byte-compile-file (concat user-emacs-directory "init.el")))))
  
  (add-hook 'after-save-hook 'tangle-init)
  #+END_SRC
